---
marp: true
theme: default
---

<!-- class: invert -->

# JavaScript Essentials

---

<!-- class: lead -->

## In this presentation

- JS
  - Functions
  - Async
  - Arrays
  - Object destructuring, spread syntax
  - Importing/exporting
- Node, NPM, package.json

---

<!-- class: invert -->

# Functions

---

<!-- class: lead -->

## JS function basics

JS functions can look very familiar. In this simple example we see a function which takes a parameter and returns a value.

```javascript
function greet(name) {
  return `Hello, ${name}!`;
}
```

---

<style scoped>
  section {
    font-size: 20px; /* Adjust this value as needed */
  }
</style>

## JS functions, alternate syntaxes

JS Functions can be defined using alternative syntaxes.

#### Function Declaration

```javascript
function greet(name) {
  return `Hello, ${name}!`;
}
```

#### Function Expression

```javascript
const greet = function (name) {
  return `Hello, ${name}!`;
};
```

#### Arrow Function

```javascript
const greet = (name) => `Hello, ${name}!`;
```

---

<style scoped>
  section {
    font-size: 22px;
  }
</style>

## Anonymous functions

- Unlike programming languages like C#, functions are commonly treated as first class objects in JS.
- Functions are passed to other functions and returned by functions.
- What is the expected output of the code below?

```javascript
const getTransformer = (isUpperCase) => {
  if (isUpperCase) {
    return (inputString) => {
      return inputString.toUpperCase();
    };
  }
  return (inputString) => {
    return inputString.toLowerCase();
  };
};

const transformString = (stringToTransform, transformer) => {
  return transformer(stringToTransform);
};

const message = "Hello Inholland";
console.log(transformString(message, getTransformer(true)));
console.log(transformString(message, getTransformer(false)));
```

---

## `this` keyword in functions

Functions in JS are objects. `this` can refer to the object context.

When the function is declared `this` refers to the object context of that function.

In arrow functions, `this` refers to the parent's object context.

```javascript
function Car(sound) {
  this.sound = sound;
  this.go = () => {
    console.log(this.sound);
  };
}
const car = new Car("vrooooom!");
car.go();
```

---

<!-- class: invert -->

# Async Code

---

<!-- class: lead -->

## Async Code in JS

Unlike programming languages like C# and Java which support asynchronous programming but don't always use it, asynchronous programming is _essential_ in JS.

Part of the reason Node and JS make such heavy use of asynchronous code is because JS is single threaded. A JS process runs in a single thread and can only perform one operation at a time. If a slow operation (i.e. network or database call) occurs, without async code, the JS thread would be blocked and unable to perform any other operations. This would result in an inefficient and unresponsive application.

Async code in JS allows the single application thread to continue to do other work while the asynchronous operation completes. Once the asynchronous operation completes, the JS thread returns to the location in code and resumes operations there.

---

## Callbacks

There are three main ways to deal with async code: `callbacks`, `promises` and `async`.

Callbacks are the oldest style. They work by passing a function to another function. After the asynchronous action is complete, the callback function is called.

Callback functions are no longer preferred in most cases but are still commonly seen, especially in older libraries.

---

## Callback Example

What is the order of the output? Which console log runs first?

Can you find _both_ callback functions in this example?

```javascript
function fetchData(callback) {
  console.log("Fetching data...");
  // Simulate async operation (e.g., API call)
  setTimeout(() => {
    const data = { name: "Alice", age: 25 };
    callback(data); // call the callback when done
  }, 2000);
}

fetchData((result) => {
  console.log("Data received:", result);
});

console.log("At the end of the script.");
```

---

## Promises

The Promise object represents the eventual completion (or failure) of an asynchronous operation and its resulting value.

Promises can be in one of three states:

- `pending`: The promise has not completed.
- `fulfilled`: The promise completed successfully.
- `rejected`: The promise failed.

Promises have three main methods:

- `.then()`: Invoked after successful completion
- `.catch()`: Invoked if an error occurs
- `.finally()`: Invoked on success _or_ error

---

## Promise Example 1/2

```javascript
// Simulated API call
function fakeApiCall() {
  return new Promise((resolve, reject) => {
    console.log("📞 Calling the server...");

    setTimeout(() => {
      const success = Math.random() > 0.3; // 70% chance of success

      if (success) {
        resolve("🎉 Data received: { user: 'Alice', age: 25 }");
      } else {
        reject("💥 Server error: something went wrong!");
      }
    }, 2000); // wait 2 seconds to simulate network delay
  });
}
```

---

## Promise Example 2/2

```javascript
// Use the promise
fakeApiCall()
  .then((data) => {
    console.log("✅ Success:", data);
  })
  .catch((error) => {
    console.error("❌ Error:", error);
  })
  .finally(() => {
    console.log("🔚 API call finished (success or fail).");
  });
```

---

## async/await

- is the preferred way to write asynchronous code in JS
- allows us to write asynchronous code that is not deeply nested (i.e. a promise, inside a promise, inside a promise)
- allows us to use `try/catch` blocks to catch errors

To use `async/await` the asynchronous function must be declared `async` and when calling the `async` function, we must `await` it.

`async` functions are really wrappers around `Promise` objects. You can `await` a `Promise`.

---

## async/await example

```javascript
// Async function instead of manual promise
async function getNumber() {
  const num = Math.random();
  if (num > 0.5) {
    return num;
  } else {
    throw "Number too small";
  }
}

async function run() {
  try {
    const result = await getNumber();
    console.log("Success:", result);
  } catch (error) {
    console.error("Error:", error);
  }
}

run();
```

---

<!-- class: invert -->

# Arrays and Array Methods

---

<!-- class: lead -->

From this array, I want a new array with only the names of the sweet fruit. How?

```javascript
const food = [
  {
    name: "banana",
    type: "fruit",
    isSweet: true,
  },
  {
    name: "apple",
    type: "fruit",
    isSweet: true,
  },
  {
    name: "avocado",
    type: "fruit",
    isSweet: false,
  },
  {
    name: "carrot",
    type: "vegetable",
    isSweet: false,
  },
];
```

---

## JS Array Methods

Arrays are a very common data structure in JS.

JS Arrays have several powerful methods that allow for filtering, selection, mapping, etc.

JS Array methods often return new arrays. That makes these methods chainable.

Anonymous functions allow us to easily filter and transform the data in arrays.

It is uncommon to use a `for` loop when dealing with JS arrays.

---

## Array Method Example Chaining

How many items are in `sweetFruitNames` and what are their types?
What is the return type of `.find()`?
What is the meaning of `!!` in the last line?

```javascript
// get the name of all the sweet fruits
const sweetFruitNames = foodItems
  .filter((food) => food.type === "fruit" && food.isSweet === true)
  .map((food) => food.name);

console.log(sweetFruitNames);

// check if the array has a vegetable
const hasVegetable = foodItems.find((food) => food.type === "vegetable");

console.log("has vegetable:", !!hasVegetable);
```

---

## Array Method Reference (see instance methods):

[https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array)

---

<!-- class: invert -->

# Object Destructuring and Spread Syntax

---

<!-- class: lead -->

## Object Destructuring

Object destructuring allows us to to pluck properties out of objects and turn them into variables.

This is commonly used when methods are returning multiple values or if we want to make our code more readable.

```javascript
const fruit = {
  fruitName: "banana",
  type: "fruit",
  isSweet: true,
};

// destructuring the object
const { fruitName, isSweet } = fruit;

console.log(`The ${fruitName} is sweet: `, isSweet);
// ~> The banana is sweet:  true
```

---

## Array Destructuring

Arrays can also be destructured:

```javascript
const fruits = ["banana", "apple"];
const [banana, apple] = fruits;

console.log(`The first fruit is the ${banana}`);
```

---

## Spread operator

The spread operator (`...`) can be used to flatten objects and arrays and "spread" the properties into new objects or arrays.

```javascript
const baseFruit = { type: "fruit", isHealthy: true };
// spread base fruit properties into apple
const apple = { ...baseFruit, name: "apple" };
console.log(`The type of ${apple.name} is ${apple.type}`);
// ~> The type of apple is fruit
let fruits = [apple];
// spread base fruit elements into fruits array and add a new fruit
fruits = [...fruits, { ...baseFruit, name: "banana" }];
```

---

## Overriding properties

When spreading properties, it is possible to override as long as the spread comes before the new assignment.

```javascript
const baseFruit = { type: "fruit", isHealthy: true };
// spread base fruit and override type when creating a carrot
const carrot = { ...baseFruit, type: "veg", name: "carrot" };
console.log(`The type of ${carrot.name} is ${carrot.type}`);
// ~> The type of carrot is veg
```

---

## Using object destructuring on function arguments and setting defaults

The following pattern of using object destructuring when passing objects as method parameters is common. Default properties can also be set.

```javascript
const printFruit = ({ type = "fruit", isHealthy = true, name } = {}) => {
  console.log(`The ${name} is of type ${type} and is healthy: ${isHealthy}`);
};
printFruit({ name: "mango" });
// ~> The mango is of type fruit and is healthy: true
```

---

## Destructing reference

[https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Destructuring](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Destructuring)

---

<!-- class: invert -->

# Importing/exporting

---

<!-- class: lead -->

## Importing and exporting modules

JS makes makes heavy use of modules. A module is just chunk of code in a separate file that is exported and can be reused in other files. Modules can export data, functions, classes, etc. Any JS object can be exported in a module.

There are two main module systems in JS:

- **Common JS**
- **ECMAScript Modules (ESM)**

---

## Common JS

Common JS was the original module management system for Node. Generally this style is deprecated in favor of ESM (which Node fully supports) but is still commonly seen.

Common JS uses the `module.exports` property to export from a module and `require()` to import that module from another file.

Common JS is typically only used outside the browser context (typically on the server).

---

## Common JS Example

_Avoid this style in favor of ESM (which Node supports)!_

```javascript
// foo.js
const myFunction = () => {
  console.log("foo!");
};

module.exports = myFunction;
```

```javascript
// index.js
const foo = require("./foo");
foo(); // ~> foo!
```

---

## ECMAScript modules (ESM)

ESM is the official JS module system.

ESM is designed to work both in the browser and on the server.

ESM exports items from a file using the `export` statement and imports them using the `import` statement. Object destructuring is commonly used when importing module items.

---

## ESM export example

Use the `export` keyword to export anything from a file.

Use `export default` to define the default export.

```javascript
// fruit.js
export const fruitType = "fruit";

export const printFruit = ({ type, name }) => {
  console.log(`Fruit type: ${type}, name: ${name}`);
};

export default class Fruit {
  constructor({ type = fruitType, name } = {}) {
    this.type = type;
    this.name = name;
  }
}
```

---

## ESM import example

Use `import` keyword to import items from another module.

The `default export` (the `Fruit` class) does not need to be destructured but the non-default exports do.

```javascript
// index.js
import Fruit, { fruitType, printFruit } from "./fruit.js";
const apple = new Fruit({ type: fruitType, name: "apple" });
printFruit(apple);
// ~> Fruit type: fruit, name: apple
```

---

<!-- class: invert -->

# Node, NPM, package.json

---

<!-- class: lead -->

## 🧐 What is Node.js?

- A **JavaScript runtime** built on **Chrome's V8 engine**
- Allows you to **run JS on the server** 🌐
- Great for **web servers, scripts, and CLI tools**
- Uses **non-blocking, event-driven architecture**

---

## 💡 Why Use Node.js?

- Fast execution with **V8 engine**
- **npm ecosystem** with thousands of packages
- Single language for **frontend + backend**
- Popular in startups & large apps (Netflix, Uber, etc.)

---

## 🧰 Installing Node.js

1. Download from [nodejs.org](https://nodejs.org/)
2. Verify installation:

```bash
node -v
npm -v
```

- `node -v` → check Node version
- `npm -v` → check npm version

---

## 📦 What is npm?

- Stands for **Node Package Manager**
- Installs **libraries and tools** for Node.js
- Helps manage **dependencies** in a project
- Comes **bundled with Node.js**

---

## 🔧 Installing Packages

- Globally:

```bash
npm install -g typescript
```

- Locally in project:

```bash
npm install express
```

- Run scripts defined in **package.json**:

```bash
npm run start
```

---

## 📝 What is `package.json`?

- A **manifest file** for your Node.js project
- Stores:

  - Project info (`name`, `version`, etc.)
  - Dependencies (`dependencies`, `devDependencies`)
  - Scripts (`start`, `test`)

- Created with:

```bash
npm init
```

---

## 📌 Example `package.json`

```json
{
  "name": "my-app",
  "version": "1.0.0",
  "main": "index.js",
  "scripts": {
    "start": "node index.js",
    "test": "echo \"No tests yet\""
  },
  "dependencies": {
    "express": "^4.18.2"
  }
}
```

- `scripts` → commands you can run with `npm run <name>`
- `dependencies` → libraries needed in production

---

## ⚡ Running a Node Project

1. Install dependencies:

```bash
npm install
```

2. Run your app:

```bash
npm run start
```

3. Optional: check installed packages:

```bash
npm list
```

---

## 🔍 Dev Dependencies

- Libraries only needed during development:

```bash
npm install --save-dev nodemon
```

- Example use: auto-reload server during coding

---

## 🎯 Summary

- **Node.js** = JS runtime for server-side
- **npm** = package manager for Node.js
- **package.json** = project manifest, scripts & dependencies
- Install packages & run scripts to manage projects efficiently

---

## 📚 Resources

- [Node.js Docs](https://nodejs.org/en/docs/)
- [npm Docs](https://docs.npmjs.com/)
- [npm Package Search](https://www.npmjs.com/)
